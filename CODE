import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from sklearn.datasets import make_classification
from sklearn.decomposition import PCA

# Step 1: Generate Synthetic Cyber-Security Dataset
num_samples = 2000
num_features = 10  # Number of security-related features

X, y = make_classification(
    n_samples=num_samples,
    n_features=num_features,
    n_informative=8,
    n_redundant=2,
    n_classes=2,
    weights=[0.7, 0.3],  # 70% normal, 30% attack
    random_state=42
)

# Convert to DataFrame for visualization
df = pd.DataFrame(X, columns=[f'Feature_{i+1}' for i in range(num_features)])
df['Target'] = y

print(df)

# Step 2: Data Visualization - Feature Distribution
plt.figure(figsize=(12, 6))
for i in range(1, 4):  # Visualizing first 3 features
    plt.subplot(1, 3, i)
    sns.histplot(df, x=f'Feature_{i}', hue="Target", kde=True, bins=30, palette="coolwarm")
    plt.title(f'Distribution of Feature {i}')
plt.tight_layout()
plt.show()

# Splitting data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Standardizing the features
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Step 3: Implement SVM Model
svm_model = SVC(kernel='rbf', C=1.0, gamma='scale', probability=True)
svm_model.fit(X_train, y_train)

# Step 4: Model Evaluation
y_pred = svm_model.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)
conf_matrix = confusion_matrix(y_test, y_pred)
class_report = classification_report(y_test, y_pred)

# Display results
print(f"ðŸ”¹ Model Accuracy: {accuracy:.4f}")
print("\nðŸ”¹ Confusion Matrix:\n", conf_matrix)
print("\nðŸ”¹ Classification Report:\n", class_report)

# Step 5: Visualization - Confusion Matrix
plt.figure(figsize=(5, 4))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='coolwarm', xticklabels=["Normal", "Attack"], yticklabels=["Normal", "Attack"])
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("Confusion Matrix")
plt.show()

# Step 6: Visualization - Decision Boundary (2D Projection using PCA)
pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_test)
df_pca = pd.DataFrame(X_pca, columns=["PC1", "PC2"])
df_pca['Target'] = y_test
df_pca['Prediction'] = y_pred

plt.figure(figsize=(8, 6))
sns.scatterplot(data=df_pca, x="PC1", y="PC2", hue="Prediction", style="Target", palette="coolwarm")
plt.title("SVM Decision Boundary (2D PCA Projection)")
plt.legend(title="Predicted")
plt.show()

# Step 7: Dynamic Real-Time Prediction Function
def predict_security_threat():
    print("\nðŸ”¹ Enter 10 feature values (e.g., network traffic stats):")
    user_input = np.array([float(input(f"Feature {i+1}: ")) for i in range(num_features)]).reshape(1, -1)
    user_input_scaled = scaler.transform(user_input)

    prediction = svm_model.predict(user_input_scaled)[0]
    confidence = svm_model.predict_proba(user_input_scaled)[0]

    print("\nðŸ”¹ Prediction Result:")
    if prediction == 0:
        print("âœ… Normal Traffic (Confidence: {:.2f}%)".format(confidence[0] * 100))
    else:
        print("ðŸš¨ Cyber Attack Detected! (Confidence: {:.2f}%)".format(confidence[1] * 100))

# Call the function for real-time prediction
predict_security_threat()
